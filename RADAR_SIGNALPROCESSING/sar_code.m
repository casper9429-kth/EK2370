% Matlab code for sar radar
% Author: Casper Augustsson
% This code needs a pre generated .mat file of name data_sync_fs.mat
% The .mat file should contain the following variables
% data: data from the radar
% sync: sync from the radar
% fs: sampling frequency of the radar

% The mat file can be generated by running the 'generate_data_sync_fs.py' script in this folder

% Get path to this script

main()

% Functions

function [zero_crossings,chirp] = extract_chirp_indicies(sync)
    % Returns chrip indicies
    % indicies: indicies where the chirp starts
    % Extract upchirp index
    chirp = zeros(size(sync));
    threshold = 500;
    chirp(sync > threshold) = 1;
    chirp(sync < -threshold) = -1;
    zero_crossings = find(diff(sign(chirp)));
end


function [pos_indicies] = extract_pos_indicies(chirp_indicies)
    % Return indicies in sync where a new position starts
    % Find all indicies where a new position starts
    % Calculate the difference between all values in chirp_indicies, 
    % remember it is still indicies
    c1 = chirp_indicies(2:end) - chirp_indicies(1:end-1);

    % Set all indicies where is less than 50000 to 0, making them invalid
    c1(c1 < 50000) = 0;
    c1(c1 >=50000) = 1;   

    % All indicies where c1 corresponds to a index in chirp_indicies that is a pos index
    % Add elem in beginning of c1 with value 1 to compensate for the first removed index
    c1 = [1 c1];

    % Now use c1 to get indicies from chirp_indicies that corresponds to a pos index
    pos_indicies = chirp_indicies(c1 == 1);
end


function [signal] = hilbert_transform(data)
    % Returns the hilbert transform of data
    % data: data to be hilbert transformed
    % signal: hilbert transformed data

    signal = imag(hilbert(data));
    % Replace nan with (10^(-30))
    % signal(isnan(signal)) = 10^(-30);
end

function main()
    % Save Constants
    fs = 44100;             % sampling frequency [Hz]
    c = 3e8;                % speed of light [m/s]
    v_c = 299792458;        % speed of light [m/s]
    Ts = 1/fs;              % sampling time [s]
    Trp = 3.00;              % Position update time [s] Trp>0.25 (lec 5,slide 32)
    Nrp=int64(Trp*fs);        % Number of samples per position update
    Tp = 0.020;              % pulse width [s]
    L = 1.25;                % syntetic antenna length [m]    
    Np = int64(Tp*fs)       % Number of samples per upchirp
    fc = 2.43e9;            % center frequency [hz]
    Nsamples = int64(Tp*fs);       % number of samples per puls
    fstart = 2.408*(10^9);
    fend = 2.495*(10^9);
    BW = (fstart - fend); % bandwidth of FMCW [Hz]

    % Get folder of this script path
    path = mfilename('fullpath');
    [folder, name, ext] = fileparts(path)

    % path to data folder
    path_data = strcat(folder,'/data_sync_fs/');

    % Check if path_data exists
    if ~exist(path_data, 'dir')
        error('Path to data folder does not exist, runt generate_data_sync_fs.py')
    end

    % Find all .mat files in path_data
    files = dir(strcat(path_data,'*.mat'));
    % Loop through all files and choose the one with the highest date on format YYYY-MM-DD_HH-MM-SS.mat
    % This is done to make sure we get the latest file
    latest_file = files(1);
    for i = 1:length(files)
        if files(i).datenum > latest_file.datenum
            latest_file = files(i);
        end
    end
    % Print name of latest file
    latest_file.name
    % Set path to latest file
    path = strcat(path_data,latest_file.name);





    %path = '/home/casper/repos/EK2370/data_cots/data_sync_fs.mat';
    % Load data,sync and fs as a matdict in a .mat file

    load(path);

    % Extract chirp indicies
    [zero_crossings,chirp] = extract_chirp_indicies(sync);

    % Find most coomon difference between chirp indicies
    diff = zero_crossings(2:end) - zero_crossings(1:end-1);
    samples_per_chirp = median(diff);

    % Extract position indicies
    pos_indicies = extract_pos_indicies(zero_crossings);

    % Plot pos_indicies 
    % zero = zeros(size(sync));
    % zero(pos_indicies) = 1;
    % plot(sync)
    % hold on
    % plot(zero*1000)
    % hold off
    % pause(0.5)

    % calculate the chirps to remove 
    chirps_to_remove = int64(0.5*Nrp/samples_per_chirp);
    chirps_to_save = int64(Nrp/samples_per_chirp);
    nr_pos = length(pos_indicies);

    % Create a matrix to store the chirps in 
    data_matrix = zeros(nr_pos,Nrp);
    data_matrix_no_sync = zeros(nr_pos,Nrp);
    sync_matrix = zeros(nr_pos,Nrp);
    data_matrix_integrated = zeros(nr_pos,Np);


    % Loop through all positions
    for i = 1:nr_pos
        % Get position index
        pos_index = pos_indicies(i);

        % Find index of pos_index in zero_crossings
        %index = np.where(chirp_indicies == pos_index)[0][0] + chrips_to_remove
        index = find(zero_crossings == pos_index) + chirps_to_remove;
        % If sync at index is negative, the sync at index +1 is positive
        start_index = zero_crossings(index);

        % Make sure it is a upchirp
        if chirp(start_index) > 0
            index = index + 1;
            start_index = zero_crossings(index);

        end



        % Fill in data_matrix and sync_matrix
        data_matrix(i,:) = data(start_index:start_index + Nrp -1);
        sync_matrix(i,:) = chirp(start_index:start_index + Nrp -1);
        up_chirp = chirp(start_index:start_index + Nrp -1);
        up_chirp(up_chirp < 0) = 0;
        % Multiply data_matrix with up_chirp to remove chirp data
        data_matrix_no_sync(i,:) = data_matrix(i,:).*up_chirp;
        % plot(data_matrix_no_sync(i,:))
        % hold off
        % pause(0.5)

        % Time to create a mean chirp
        sync_clean = sync_matrix(i,:);
        % Find arguements where sync_clean goes from -1 to 1
        delta_sync = sync_clean(2:end) - sync_clean(1:end-1);
        delta_sync = [0 delta_sync ];
        arg_up_chirp_start = find(delta_sync == 2);
        % Create a matrix to store the chirps in
        chirp_matrix = zeros(length(arg_up_chirp_start)-2,Np);
        for j = 1:(length(arg_up_chirp_start)-2)
            start_save_index = arg_up_chirp_start(j);
            % Check if start_save_index + Np - 1 is larger than data_matrix_no_sync
            chirp_matrix(j,:) = data_matrix_no_sync(i,start_save_index:start_save_index + Np -1);
            % plot(chirp_matrix(j,:))
            % hold on
        end
        % Create mean along columns
        chirp_matrix_mean = mean(chirp_matrix,1);
        data_matrix_integrated(i,:) = chirp_matrix_mean;
        % plot(chirp_matrix_mean)
        % hold off
        % pause(0.5)
    end


    % Cut away second half of data matrix integrated
    data_matrix_integrated = data_matrix_integrated(:,1:size(data_matrix_integrated,2)/2);

    % Do hilbert transform on data_matrix_integrated
    data_matrix_integrated_hilbert = zeros(size(data_matrix_integrated));
    for i = 1:nr_pos
        data_matrix_integrated_hilbert(i,:) = hilbert_transform(data_matrix_integrated(i,:));
    end

    % Plot data_matrix_integrated_hilbert
    % for i = 1:nr_pos
    %     plot(data_matrix_integrated(i,:))
    %     hold on
    %     plot(data_matrix_integrated_hilbert(i,:))
    %     hold off
    %     pause(0.5)
    % end


    % Apply hann window to each row of data_matrix_integrated_hilbert 
    hann_window = hann(Np/2);
    data_matrix_integrated_hilbert_hann = data_matrix_integrated_hilbert(:,1:Np/2).*hann_window';
    % Plot data_matrix_integrated_hilbert_hann
    % for i = 1:nr_pos
    %     plot(data_matrix_integrated_hilbert(i,:))
    %     hold on
    %     plot(data_matrix_integrated_hilbert_hann(i,:))
    %     hold off
    %     pause(0.5)
    % end

    % Create Kr vector 
    %4 pi f_start/c -> 4 pi f_end/c     in Np/2 steps
    s_ls = 4*pi*fstart/v_c;
    s_le = 4*pi*fend/v_c;
    Kr = linspace(s_ls,s_le,Np/2);
    Xa = linspace(-0.7,0.7,nr_pos);
    lambda = L*2/nr_pos;
    Kx = linspace(-2*pi/lambda,2*pi/lambda,nr_pos+2024);
    % Linspace from 1 to nr_pos in 2024 + nr_pos steps
    %Kx = linspace(1,nr_pos,nr_pos + 2024);


    % Plot the phase of data_matrix_integrated_hilbert_hann 
    %imagesc(Kr,Xa,data_matrix_integrated_hilbert_hann)

    % Zero padd matrix
    % 1012 zeros at the top of each column
    % 1012 zeros at the bottom of each column
    data_matrix_integrated_hilbert_hann_zero_padded = zeros(nr_pos + 2*1012,Np/2);
    data_matrix_integrated_hilbert_hann_zero_padded(1013:end-1012,:) = data_matrix_integrated_hilbert_hann;

    % Plot data_matrix_integrated_hilbert_hann_zero_padded
    % imagesc(Kr,Xa,data_matrix_integrated_hilbert_hann_zero_padded)

    % Peform fft on each column and fftshift 
    data_matrix_integrated_hilbert_hann_zero_padded_fft = fft(data_matrix_integrated_hilbert_hann_zero_padded,[],1);
    data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted = fftshift(data_matrix_integrated_hilbert_hann_zero_padded_fft,1);
    
    % Create Ky matrix
    % Ky = zeros(size(data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted));
    % % Fill ky with Kr and Kx. x is the first dimension and r is the second
    % for i = 1:size(data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted,1)
    %     Ky(i,:) = sqrt(Kr.^2 - Kx(i).^2);
    % end
    Ky = sqrt(Kr.^2 - Kx'.^2);
    
    % Calculate Kye
    min_Ky = min(min(Ky));
    max_Ky = max(max(Ky));
    length_of_kye = int64(size(data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted,1)/2);
    Kye = linspace(min_Ky,max_Ky,length_of_kye);

    % Data_matrix_interp
    data_matrix_interp = zeros(size(data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted,1),int64(size(data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted,1)/2));
    for i = 1:size(data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted,1)
        data_matrix_interp(i,:) = interp1(Ky(i,:),data_matrix_integrated_hilbert_hann_zero_padded_fft_shifted(i,:),Kye);
    end

    % Replace nan with 10^(-30)
    data_matrix_interp(isnan(data_matrix_interp)) = 10^(-30);

    size(data_matrix_interp)

    % Plot imagesc(Kye, Kx, angle(Interpolated Data Matrix))
    % imagesc(Kye,Kx,angle(data_matrix_interp))

    % Do ifft2d on data_matrix_interp with 4x zero padding
    data_matrix_interp_ifft = ifft2(data_matrix_interp,4*size(data_matrix_interp,1),4*size(data_matrix_interp,2));
    size(data_matrix_interp_ifft)    

    % Plot log(abs(data_matrix_interp_ifft)), not done yet. But needing some joy!
    %imagesc(Kye,Kx,log(abs(data_matrix_interp_ifft)))
    % Rotate -90 degrees and flip left to right of data_matrix_interp_ifft
    data_matrix_interp_ifft = rot90(data_matrix_interp_ifft,-1);
    data_matrix_interp_ifft = fliplr(data_matrix_interp_ifft);


    % Scale image a little bit to make it look better
    dfy = v_c*(Kye(end)-Kye(1))/(pi)
    Rmax = (4*size(data_matrix_interp,1))*v_c/(2*dfy)
    Rail_Rmax = 2*pi/lambda

    d_range_1 = 1
    d_range_2 = 100
    c_range_1 = -25
    c_range_2 = 25

    d_index_1 = round((size(data_matrix_interp_ifft,1)/Rmax) * d_range_1)
    d_index_2 = round((size(data_matrix_interp_ifft,1)/Rmax) * d_range_2)
    
    c_index_1 = round((size(data_matrix_interp_ifft,2)/Rail_Rmax)*(c_range_1+(Rail_Rmax/2)))
    c_index_2 = round((size(data_matrix_interp_ifft,2)/Rail_Rmax)*(c_range_2+(Rail_Rmax/2)))





    % Cutout the part of data_matrix_interp_ifft_rotated_flipped that we want from d_index_1 to d_index_2 and c_index_1 to c_index_2
    data_matrix_interp_ifft = data_matrix_interp_ifft(d_index_1:d_index_2,c_index_1:c_index_2);

    down_range_vector = linspace(d_range_1,d_range_2,size(data_matrix_interp_ifft,1));
    cross_range_vector = linspace(c_range_1,c_range_2,size(data_matrix_interp_ifft,2));
    % take the power of 2 of down_range_vector elementwise
    down_range_vector = down_range_vector.^2;

    % Multiply with down_range_vector on all columns
    %data_matrix_interp_ifft = data_matrix_interp_ifft.*down_range_vector';


    % Fallten data_matrix_interp_ifft
    data_matrix_interp_ifft_flattened = abs(reshape(data_matrix_interp_ifft,1,[]));
    
    % Find a precentile of the data_matrix_interp_ifft_flattened
    precentile_min = prctile(data_matrix_interp_ifft_flattened,50);
    precentile_max = prctile(data_matrix_interp_ifft_flattened,100);

    %precentile_max = prctile(data_matrix_interp_ifft_flattened,99.9);


    % Set all values in data_matrix_interp_ifft that is less than precentile_min to precentile_mi
    data_matrix_interp_ifft(abs(data_matrix_interp_ifft)>precentile_max)   = precentile_max;
    data_matrix_interp_ifft(abs(data_matrix_interp_ifft) < precentile_min) = precentile_min;

    % Plot log(abs(data_matrix_interp_ifft_rotated_flipped_cutout))
    imagesc(c_range_1:c_range_2,-d_range_2:-d_range_1,log(abs(fliplr(rot90(data_matrix_interp_ifft,2)))))
    % Add axis labels
    xlabel('Cross Range [m]')
    ylabel('Down Range [m]')    


end

